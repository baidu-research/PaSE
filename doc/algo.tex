\documentclass{article}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{algorithm,algpseudocode}
\usepackage[margin=1in]{geometry}

\algnewcommand{\LongComment}[2]{\Comment{\parbox[t]{#1}{#2}}}
\algnewcommand{\LeftComment}[1]{\State \(\triangleright\) #1}

\newcommand{\rom}[1]{\uppercase\expandafter{\romannumeral #1\relax}}
\newcommand{\Inputs}[1]{\State \textbf{Input(s): }\parbox[t]{.8\textwidth}{#1}}
\newcommand{\Outputs}[1]{\State \textbf{Output(s): }\parbox[t]{.8\textwidth}{#1}}
\newcommand{\strategy}{\mathcal{S}}
\newcommand{\optstrategy}{\widehat{\mathcal{S}}}
\newcommand{\optcost}{\widehat{T}}
\newcommand{\minv}{v_{min}}
\newcommand{\vertcost}[1]{t_V(#1)}
\newcommand{\edgecost}[1]{t_E(#1)}
\newcommand{\neighbors}{n}
\newcommand{\uneigh}{un}
%\newcommand{\processed}{p}
\newcommand{\configs}{cfg}

\newtheorem{theorem}{Theorem}

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}
\newcommand{\set}[1]{\{#1\}}

\begin{document}

\begin{algorithm}
\caption{\label{alg:findoptstrategy}Algorithm to determine optimal parallelization
strategy for an operator DAG}

\begin{algorithmic}[1]
	\Procedure{FindOptStrategy}{$G=(V,E)$, $nprocs$}
	\Inputs{$G=(V,E):$ Operator DAG.\\
	$(\forall{v\in V})[v.dim]:$ Dimension of the iteration domain of the operation of
	$v$.\\
	$nprocs:$ Number of processors.}
	\Outputs{$\strategy$: Optimal parallelization starategy for $G$ }
	\Statex

	\LeftComment{Initialize vertex properties}
	\ForAll{$v \in V$}
		\State $v.\neighbors \leftarrow  \set{u ~|~ (u,v) \in E \lor (v,u) \in E}$
		\Comment{Neighbors}
		\State $v.\uneigh \leftarrow v.\neighbors$ \Comment{Unprocessed neighbors}
		%\State $v.\processed \leftarrow \bot$
		\State $v.\configs \leftarrow \set{(c_1, c_2,\dots,c_{v.dim}) ~|~
		(\forall{i\in[1,v.dim]})[c_i\in \mathbb{Z^+}]\land \prod_{i=1}^{v.dim} c_i \le
		nprocs}$ \\ \Comment{Set of all possible configurations}
	\EndFor

	\Statex

	\LeftComment{Populate $v.tbl$ with all possible combinations of neighboring
	configurations. Each entry in $v.tbl$ is a sub-strategy for the nodes $\set{v}
	\cup v.\neighbors$}
	\ForAll{$v \in V$}
		\State \label{ln:all-configs}$v.tbl \leftarrow \prod_{u\in \set{v}\cup v.\neighbors} \set{(u, cfg)
		~|~cfg \in u.\configs}$
	\EndFor \label{ln:end-all-configs}

	\Statex

	%\State $U \leftarrow \set{v \in V ~|~v.processed = \bot}$ 
	\State $U \leftarrow V$
	\Comment{Set of unprocessed vertices}
	\While{\label{ln:loop-begin}$U \not = \emptyset$}
		\LeftComment{Choose a vertex with least no. of unprocessed neighbors from
		$U$}
		%\ForAll{$v \in U$} 
		%	\State $v.unprocessed\_neighbors \leftarrow \set{u ~|~ u, v\in U \land u\in v.neighbors}$
		%\EndFor
		\State $\minv \leftarrow \argmin_{v\in U} |v.\uneigh|$
		\Statex

		\LeftComment{Partition $\minv.tbl$ such that in each set, all the neighbor
		configurations are the same. Refer Alg.~\ref{alg:is-compatible} for the
		function \Call{IsCompatible}{}}
		\State \label{ln:partition} $\mathcal{P} \leftarrow \{S_1,S_2,\dots~|~$
		\parbox[t]{.75\textwidth}{
				$\cup_{S_i} = \minv.tbl \land i \not = j \implies S_i \cap S_j = \emptyset
				\land~\\(\forall s_x \in S_i)(\forall s_y \in
				S_i)[\Call{IsCompatible}{s_x, s_y, \minv.\neighbors} = \top]
				\land~\\i \not = j \implies (\forall s_x \in S_i)(\forall s_y \in
				S_j)[\Call{IsCompatible}{s_x, s_y, \minv.\neighbors} = \bot]
		\}$}
		\Statex
		\LeftComment{Iterate over each set $S \in \mathcal{P}$ and update
		$\minv.tbl$ so that it only contains the sub-strategy in $S$ that has the
		least cost.}
		\ForAll{$S \in \mathcal{P}$}
			\State \label{ln:opt-strategy} $best \leftarrow \argmin_{s\in S}
			\Call{Cost}{G, s}$
			\State $rem \leftarrow S \setminus \set{best}$
			\State \label{ln:pick-opt}$\minv.tbl \leftarrow \minv.tbl \setminus
			rem$
		\EndFor\label{ln:end-pick-opt}
		\Statex

		\ForAll{$v \in \minv.\neighbors$}
			\LeftComment{Restrict the tables of the neighbors based on the best
			sub-strategies found for $\minv$ in Line~\ref{ln:opt-strategy}}
			\State $common = (\minv.\neighbors \cap v.\neighbors) \cup
			\set{\minv, v}$
			\State \label{ln:restrict-neigh} $v.tbl \leftarrow \set{t_1\in v.tbl ~|~ (\exists
			t_2 \in \minv.tbl)[\Call{IsCompatible}{t_1, t_2, common) =
			\top]}}$

			\Statex

			\State $v.\uneigh \leftarrow
			v.\uneigh\setminus \set{\minv}$
		\EndFor

		\Statex
		%\State $\minv.\processed \leftarrow \top$
		\State $U \leftarrow U\setminus \set{\minv}$
	\EndWhile\label{ln:loop-end}
	\Statex

	%\LeftComment{Once all the vertices are processed, $v.tbl$ of all the vertices
	%should contain just a single entry.}
	\LeftComment{Collect all valid strategies for $G$ from $v.tbl$, and pick the
	one that minimizes the cost.}
	\State $\strategy' \leftarrow \Call{ValidStrategies}{G}$ \Comment{Refer
	Alg.~\ref{alg:valid-strategies}}
	\State $\strategy \leftarrow \argmin_{S\in \strategy'} \Call{Cost}{G, S}$
	%\ForAll{$v \in V$}
	%	\State $\strategy \leftarrow \strategy \cup sub\_strategy \in v.tbl$
	%\EndFor
	\State \Return{$\strategy$}

	\EndProcedure
\end{algorithmic}

\end{algorithm}

\begin{algorithm}
	\caption{\label{alg:is-compatible}Returns $\top$ if the two
	sub-strategies $S_1$ and $S_2$ have same configurations for the
	vertices in $V$.}

	\begin{algorithmic}[1]
		\Procedure{IsCompatible}{$S_1, S_2, V$}
			\State $N_1 \leftarrow \set{(n,c)\in S_1~|~n \in V}$
			\State $N_2 \leftarrow \set{(n,c)\in S_2~|~n \in V}$
			\Statex

			\If{$N_1 \not= N_2$}
				\State \Return{$\bot$}
			\EndIf
			\Statex
			\State \Return{$\top$}
		\EndProcedure
	\end{algorithmic}
\end{algorithm}


\begin{algorithm}
	\caption{\label{alg:valid-strategies} Returns a set of valid strategies}

	\begin{algorithmic}[1]
		\Procedure{ValidStrategies}{$G=(V,E)$}

		\State $\strategy \leftarrow \emptyset$
		\ForAll{$v \in V$}
			\If{$\strategy = \emptyset$}
				\State $\strategy \leftarrow v.tbl$
				\State \Call{Continue}{}
			\EndIf

			\Statex

			\State $\strategy' \leftarrow \emptyset$
			\ForAll{$S \in \strategy$}
				\ForAll{$T \in v.tbl$}
					\State $U_1 \leftarrow \set{u~|~(u,c)\in S}$
					\State $U_2 \leftarrow \set{u~|~(u,c)\in v.tbl}$
					\Statex
					\If{$\Call{IsCompatible}{S, T, U_1\cap U_2} = \top$}
						\State $\strategy' \leftarrow \strategy' \cup \set{S\cup T}$
					\EndIf
				\EndFor
			\EndFor
			\State $\strategy \leftarrow \strategy'$
		\EndFor

		\Statex
		\State\Return{$\strategy$}

		\EndProcedure

	\end{algorithmic}
\end{algorithm}

\clearpage

\section{Proof of optimality}
\paragraph{Notation}
Given a strategy $\strategy$ of a graph $G=(V,E)$ and $V'\subseteq V$,
$\strategy_{|V'}$ denotes the sub-strategy restricted to the subgraph of $G$
induced by $V'$, and $\strategy(v)$ denotes the configuration for the vertex $v$
in $\strategy$.  
Let $\optstrategy$ be an optimal strategy for an operator DAG
$G=(V,E)$, and $\optcost = \Call{Cost}{G, \optstrategy}$
%\sum_{v\in V} \vertcost{v, \optstrategy(v)} +
%\sum_{(u,v)\in E} \edgecost{(u,v), \optstrategy(u), \optstrategy(v)}$ 
be the optimal parallelization cost for $\optstrategy$.

Alg.~\ref{alg:valid-strategies} takes a DAG $G$ as input, whose vertices
have an associated property $tbl$ that contains a set of sub-strategies, and
returns a set of all possible valid strategies for $G$.
Line~\ref{ln:all-configs} of Alg.~\ref{alg:findoptstrategy} assigns all possible
sub-strategies to each vertex in $G$. It can be seen that just before
entering the loop at line~\ref{ln:loop-begin} in Alg.~\ref{alg:findoptstrategy},
we have $\optstrategy \in \Call{ValidStrategies}{G}$.

We will show that the invariant $(\exists\strategy \in
\Call{ValidStrategies}{G})[\Call{Cost}{G, \strategy} \le \optcost]$ is
maintained everywhere after line~\ref{ln:end-all-configs} in
Alg.~\ref{alg:findoptstrategy}.

\begin{theorem}
	Given an operation DAG $G=(V,E)$ and an optimal parallelization strategy
	$\optstrategy$ for $G$,  the invariant $(\exists\strategy \in
	\Call{ValidStrategies}{G})[\Call{Cost}{G, \strategy} \le \optcost]$ is
	maintained in any iteration of the loop $L$ in
	lines~\ref{ln:loop-begin}--\ref{ln:loop-end} of
	Alg.~\ref{alg:findoptstrategy}.

	\proof
	As a contradiction, consider that there exists an iteration $l$ of loop $L$
	where the invariant is violated for the first time. 
	Lines~\ref{ln:pick-opt} and \ref{ln:restrict-neigh} are the only places in
	loop $L$ where some of the valid sub-strategies are removed from $v.tbl$. We
	will consider both the cases below.

	\paragraph{Case \rom{1}}
	Consider line~\ref{ln:pick-opt} of Alg.~\ref{alg:findoptstrategy}.  Let
	$\phi_{l}$ be the set of valid strategies returned by
	$\Call{ValidStrategies}{G}$ at the beginning of an iteration $l$, and
	$\phi_{l+1}$ be the set of valid strategies returned at the end of iteration
	$l$.
	Let $V' = V \setminus \set{\minv}$, and $E' = E \cap (V'\times V')$.
	Note that line~\ref{ln:pick-opt} only removes some of the configurations of
	the vertex $\minv$, i.e., ${\phi_l}_{|V'}$ does not change after execution of
	line~\ref{ln:pick-opt}. 

	Let $B$ denote the set of all $best$ sub-strategies picked in
	line~\ref{ln:pick-opt} in iteration $l$. For some $\strategy \in B$,
	let $B(\strategy_{|v.n})$ denote the configuration $c$ for $v$ s.t.
	$\set{(v,c)} \cup \strategy_{|v.n} = \strategy$.
	%$(\exists b \in B)[\strategy_{|v.n} \cup \set{(v,c)} = b]$. 
	It can be seen that $B(\strategy_{|v.n})$ is unique from the construction of
	$\mathcal{P}$ in line~\ref{ln:partition}. 
	
	We have,

	\begin{align}
		\optcost & = & \min_{\strategy \in \phi_l} \{\sum_{v \in V} \vertcost{v, \strategy(v)} +
			\sum_{(u,v)\in E} \edgecost{(u,v), \strategy(u), \strategy(v)}\}\nonumber\\
		& = & \min_{\strategy \in \phi_l}\{ \vertcost{\minv, \strategy(\minv)} +
			\sum_{(u, \minv) \in E} \edgecost{(u, \minv), \strategy(u),
			\strategy(\minv)}~+  \nonumber \\
			& & \sum_{(\minv, v) \in E} \edgecost{(\minv, v), \strategy(\minv),
			\strategy(v)} +
			\sum_{v\in V'} \vertcost{v, \strategy(v)} + \sum_{(u,v) \in E'}
			\edgecost{(u,v), \strategy(u), \strategy(v)} \} \nonumber\\
		& \ge & \min_{\strategy \in \phi_l} \{\vertcost{\minv,
		B(\strategy_{|\minv.n})} +
			\sum_{(u, \minv) \in E} \edgecost{(u, \minv), \strategy(u),
			B(\strategy_{|\minv.n})} ~+  \nonumber \\
			& & \sum_{(\minv, v) \in E} \edgecost{(\minv, v), B(\strategy_{|\minv.n}),
			\strategy(v)} +
			\sum_{v\in V'} \vertcost{v, \strategy(v)} +
			\sum_{(u,v) \in E'} \edgecost{(u,v), \strategy(u), \strategy(v)}
			\}\label{eq:best}
	\end{align}
	contradicting our assumption, as there exists a strategy $\strategy \in
	\phi_l$ and $\set{(\minv, B(\strategy_{|\minv.n})) \cup \strategy_{|V'}} \in
	\phi_{l+1}$ whose cost is equal to $\optcost$.

	Eq.~\ref{eq:best} above follows from the fact that
	\[
		best = \argmin_{\strategy_{|V''}} \sum_{v \in \set{\minv}\cup
		\minv.\neighbors} \vertcost{v, \strategy_{|V''}(v)} + \sum_{(u,v) \in
		E\setminus E'} \edgecost{(u,v), \strategy_{|V''}(u), \strategy_{|V''}(v)}
	\] 


\qed
\end{theorem}


\end{document}
