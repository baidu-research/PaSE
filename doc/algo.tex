\documentclass{article}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{algorithm,algpseudocode}
\usepackage[margin=1in]{geometry}

\algnewcommand{\LongComment}[2]{\Comment{\parbox[t]{#1}{#2}}}
\algnewcommand{\LeftComment}[1]{\State \(\triangleright\) #1}

\newcommand{\rom}[1]{\uppercase\expandafter{\romannumeral #1\relax}}
\newcommand{\Inputs}[1]{\State \textbf{Input(s): }\parbox[t]{.8\textwidth}{#1}}
\newcommand{\Outputs}[1]{\State \textbf{Output(s): }\parbox[t]{.8\textwidth}{#1}}
\newcommand{\strategy}{\mathcal{S}}
\newcommand{\optstrategy}{\widehat{\mathcal{S}}}
\newcommand{\optcost}{\widehat{T}}
\newcommand{\minv}{v_{min}}
\newcommand{\vertcost}[1]{t_V(#1)}
\newcommand{\edgecost}[1]{t_E(#1)}
\newcommand{\neighbors}{n}
\newcommand{\uneigh}{un}
%\newcommand{\processed}{p}
\newcommand{\configs}{cfg}

\newtheorem{theorem}{Theorem}

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}
\newcommand{\set}[1]{\{#1\}}

\begin{document}

\section{Terminologies}
A \emph{computation graph} is a DAG $G=(V,E)$, whose vertices are the operations
performed by different layers in a model in a single timestep, and edges are the
tensors that are transferred between different operations. 
Each operation $v\in V$ has an iteration domain whose size is represented by an
ordered set.
%, and the dimensionality of the iteration domain of an operation $v \in
%V$ is represented as $v.dim$. 
For e.g., a matrix-matrix multiplication operation (GEMM) that multiplies a matrix of
size $m\times k$ with another matrix of size $k\times n$ has a three-dimensional
iteration domain of size $(m,n,k)$.

A \emph{parallelization configuration} for an operation is an ordered set of
positive integers that describes how the iteration domain of the operation is
distributed among $p$ processors. For instance, a configuration $(2,2,1)$ for
GEMM operation denotes that the iteration domain is split into $2$ along $m$ and
$n$ dimensions, and distributed among $4$ processors.

A \emph{parallelization strategy} for a graph $G=(V,E)$ is a map $\strategy: V \rightarrow
\mathbb{(Z^+)}^{d}$, where $d=\max_{v\in V} v.dim$, that
assigns a valid configuration to each vertex in $G$. For e.g., the strategy
$\set{(v_1, (2,1,1)), (v_2, (1,2,1))}$ denotes that the vertex $v_1$ is divided
among two processors along its first iteration domain dimension, and the vertex
$v_2$ is divided among two processors along its second dimension. An optimal
parallelization strategy is the one that minimizes the total execution time of
the graph.

Given a strategy $\strategy$, total execution time of $G$ under $\strategy$ is
given by $t_G(G, \strategy) = \sum_{v\in V} \vertcost{v, \strategy(v)} +
\sum_{(u,v)\in E} \edgecost{(u,v), \strategy(u), \strategy(v)}$, where
$\vertcost{v,c_v}$ provides the time to execute the operation of $v$ (i.e.,
perform computation and communication such as gradient synchronization, etc.,)
under the configuration $c_v$, and $\edgecost{(u,v), c_u, c_v}$ provides the
time to communicate the tensors between operations (e.g., time for all-to-all
communication to transpose the matrices).

\section{Finding an optimal strategy for a computation graph}
A brute-force method to find an optimal strategy is to enumerate all possible
strategies, and pick the one that minimizes the total time. However, as this
algorithm is exponential in complexity, it is not practical to analyze all
possible strategies. Given a strategy $\strategy$ for $G$, it can be seen that
if we change a configuration $c=\strategy(v)$ for a vertex $v$, it only affects
the execution time of $v$ and the communication time with its neighbors. We make
use of this insight to efficiently compute an optimal strategy in
Alg.~\ref{alg:findoptstrategy}. Particularly, given a vertex $v$ and a
strategy $\strategy$ for $G$, we can determine what would be the change in total
execution time of the graph if we change the configuration for $v$ from, say,
$c_1$ to $c_2$, by just looking at the configurations of the neighbors of $v$ in
$\strategy$. Hence, if we have a set of possible configurations $\set{c_1, \dots
c_n}$ for $v$, if changing from $c_i$ to $c_j$ provides a positive difference
in execution time, then $c_i$ is sub-optimal under $\strategy$. This allows us
to reduce the search space by removing $c_i$ from consideration for $\strategy$.
A formal proof of optimality is provided in Thm.~\ref{thm:optimality}.

Alg.~\ref{alg:findoptstrategy} takes a computation graph $G$ and the number of
available processors as input, and returns an optimal strategy for $G$.
Line~\ref{ln:all-configs} enumerates all possible configurations for a vertex.
In lines~\ref{ln:start-all-sub-strategies}--\ref{ln:end-all-sub-strategies}
enumerate all possible sub-strategies for a vertex $v$ and its neighbors from
their configurations. These sub-strategies provide sufficient information needed
to compute the change in the total execution time when we change a configuration
for $v$.

In lines~\ref{ln:loop-begin}--\ref{ln:loop-end}, in each iteration of the loop,
we consider a vertex $v$ in the graph, and we determine what is the best
configuration for $v$ (line~\ref{ln:pick-opt}) for each combination of its
neighboring configurations. Any sub-optimal configurations are eliminated, thus
reducing the search space of the strategies to be validated for optimality.

Once all the vertices have been processed, we collect all remaining valid
strategies from the configurations stored in the vertices (after the sub-optimal
ones have been eliminated), we choose the one that provides the minimum cost in
line~\ref{ln:opt-strategy}. In Thm.~\ref{thm:optimality} we show that the final
strategy returned by Alg.~\ref{alg:findoptstrategy} is an optimal one.

\begin{algorithm}
\caption{\label{alg:findoptstrategy}Algorithm to determine optimal parallelization
strategy for a computation DAG}

\begin{algorithmic}[1]
	\Procedure{FindOptStrategy}{$G=(V,E)$, $nprocs$}
	\Inputs{$G=(V,E):$ Computation DAG.\\
	$(\forall{v\in V})[v.dim]:$ Dimension of the iteration domain of the operation of
	$v$.\\
	$nprocs:$ Number of processors.}
	\Outputs{$\strategy$: Optimal parallelization starategy for $G$ }
	\Statex

	\LeftComment{Initialize vertex properties}
	\ForAll{$v \in V$}
		\State $v.\neighbors \leftarrow  \set{u ~|~ (u,v) \in E \lor (v,u) \in E}$
		\Comment{Neighbors}
		\State $v.\uneigh \leftarrow v.\neighbors$ \Comment{Unprocessed neighbors}
		%\State $v.\processed \leftarrow \bot$
		\State \label{ln:all-configs} $v.\configs \leftarrow \set{(c_1, c_2,\dots,c_{v.dim}) ~|~
		(\forall{i\in[1,v.dim]})[c_i\in \mathbb{Z^+}]\land \prod_{i=1}^{v.dim} c_i \le
		nprocs}$ \\ \Comment{Set of all possible configurations}
	\EndFor

	\Statex

	\LeftComment{Populate $v.tbl$ with all possible combinations of neighboring
	configurations. Each entry in $v.tbl$ is a sub-strategy for the nodes $\set{v}
	\cup v.\neighbors$}
	\ForAll{$v \in V$}\label{ln:start-all-sub-strategies}
		\State \label{ln:all-sub-strategies}$v.tbl \leftarrow \prod_{u\in \set{v}\cup v.\neighbors} \set{(u, cfg)
		~|~cfg \in u.\configs}$
	\EndFor \label{ln:end-all-sub-strategies}

	\Statex

	%\State $U \leftarrow \set{v \in V ~|~v.processed = \bot}$ 
	\State $U \leftarrow V$
	\Comment{Set of unprocessed vertices}
	\While{\label{ln:loop-begin}$U \not = \emptyset$}
		\LeftComment{Choose a vertex with least no. of unprocessed neighbors from
		$U$}
		%\ForAll{$v \in U$} 
		%	\State $v.unprocessed\_neighbors \leftarrow \set{u ~|~ u, v\in U \land u\in v.neighbors}$
		%\EndFor
		\State $\minv \leftarrow \argmin_{v\in U} |v.\uneigh|$
		\Statex

		\LeftComment{Partition $\minv.tbl$ such that in each set, all the neighbor
		configurations are the same. Refer Alg.~\ref{alg:is-valid} for the
		function \Call{IsValid}{}}
		\State \label{ln:partition} $\mathcal{P} \leftarrow \{S_1,S_2,\dots~|~$
		\parbox[t]{.75\textwidth}{
				$\cup_{S_i} = \minv.tbl \land i \not = j \implies S_i \cap S_j = \emptyset
				\land~\\(\forall s_x \in S_i)(\forall s_y \in
				S_i)[\Call{IsValid}{s_x, s_y, \minv.\neighbors} = \top]
				\land~\\i \not = j \implies (\forall s_x \in S_i)(\forall s_y \in
				S_j)[\Call{IsValid}{s_x, s_y, \minv.\neighbors} = \bot]
		\}$}
		\Statex
		\LeftComment{Iterate over each set $S \in \mathcal{P}$ and update
		$\minv.tbl$ so that it only contains the sub-strategy in $S$ that has the
		least cost.}
		\ForAll{$S \in \mathcal{P}$}
			\State \label{ln:opt-strategy} $best \leftarrow \argmin_{s\in S}
			\Call{Cost}{G, s}$
			\State $rem \leftarrow S \setminus \set{best}$
			\State \label{ln:pick-opt}$\minv.tbl \leftarrow \minv.tbl \setminus
			rem$
		\EndFor\label{ln:end-pick-opt}
		\Statex

		\ForAll{$v \in \minv.\neighbors$}
			\LeftComment{Restrict the tables of the neighbors based on the best
			sub-strategies found for $\minv$ in Line~\ref{ln:opt-strategy}}
			\State $common = (\minv.\neighbors \cap v.\neighbors) \cup
			\set{\minv, v}$
			\State \label{ln:restrict-neigh} $v.tbl \leftarrow \set{t_1\in v.tbl ~|~ (\exists
			t_2 \in \minv.tbl)[\Call{IsValid}{t_1, t_2, common) =
			\top]}}$

			\Statex

			\State $v.\uneigh \leftarrow
			v.\uneigh\setminus \set{\minv}$
		\EndFor

		\Statex
		%\State $\minv.\processed \leftarrow \top$
		\State $U \leftarrow U\setminus \set{\minv}$
	\EndWhile\label{ln:loop-end}
	\Statex

	%\LeftComment{Once all the vertices are processed, $v.tbl$ of all the vertices
	%should contain just a single entry.}
	\LeftComment{Collect all valid strategies for $G$ from $v.tbl$, and pick the
	one that minimizes the cost.}
	\State $\strategy' \leftarrow \Call{ValidStrategies}{G}$ \Comment{Refer
	Alg.~\ref{alg:valid-strategies}}
	\State \label{ln:opt-strategy}$\strategy \leftarrow \argmin_{S\in \strategy'} \Call{Cost}{G, S}$
	%\ForAll{$v \in V$}
	%	\State $\strategy \leftarrow \strategy \cup sub\_strategy \in v.tbl$
	%\EndFor
	\State \Return{$\strategy$}

	\EndProcedure
\end{algorithmic}

\end{algorithm}

\begin{algorithm}
	\caption{\label{alg:is-valid}Returns $\top$ if the two
	sub-strategies $S_1$ and $S_2$ have same configurations for the
	vertices in $V$.}

	\begin{algorithmic}[1]
		\Procedure{IsValid}{$S_1, S_2, V$}
			\State $N_1 \leftarrow \set{(n,c)\in S_1~|~n \in V}$
			\State $N_2 \leftarrow \set{(n,c)\in S_2~|~n \in V}$
			\Statex

			\If{$N_1 \not= N_2$}
				\State \Return{$\bot$}
			\EndIf
			\Statex
			\State \Return{$\top$}
		\EndProcedure
	\end{algorithmic}
\end{algorithm}


\begin{algorithm}
	\caption{\label{alg:valid-strategies} Returns a set of valid strategies}

	\begin{algorithmic}[1]
		\Procedure{ValidStrategies}{$G=(V,E)$}

		\State $\strategy \leftarrow \emptyset$
		\ForAll{$v \in V$}
			\If{$\strategy = \emptyset$}
				\State $\strategy \leftarrow v.tbl$
				\State \Call{Continue}{}
			\EndIf

			\Statex

			\State $\strategy' \leftarrow \emptyset$
			\ForAll{$S \in \strategy$}
				\ForAll{$T \in v.tbl$}
					\State $U_1 \leftarrow \set{u~|~(u,c)\in S}$
					\State $U_2 \leftarrow \set{u~|~(u,c)\in v.tbl}$
					\Statex
					\If{$\Call{IsValid}{S, T, U_1\cap U_2} = \top$}
						\State $\strategy' \leftarrow \strategy' \cup \set{S\cup T}$
					\EndIf
				\EndFor
			\EndFor
			\State $\strategy \leftarrow \strategy'$
		\EndFor

		\Statex
		\State\Return{$\strategy$}

		\EndProcedure

	\end{algorithmic}
\end{algorithm}

\clearpage

\section{Proof of optimality}
\paragraph{Notation}
Given a strategy $\strategy$ of a graph $G=(V,E)$ and $V'\subseteq V$,
$\strategy_{|V'}$ denotes the sub-strategy restricted to the subgraph of $G$
induced by $V'$, and $\strategy(v)$ denotes the configuration for the vertex $v$
in $\strategy$.  
Let $\optstrategy$ be an optimal strategy for a computation DAG
$G=(V,E)$, and $\optcost = \Call{Cost}{G, \optstrategy}$
%\sum_{v\in V} \vertcost{v, \optstrategy(v)} +
%\sum_{(u,v)\in E} \edgecost{(u,v), \optstrategy(u), \optstrategy(v)}$ 
be the optimal parallelization cost for $\optstrategy$.

Alg.~\ref{alg:valid-strategies} takes a DAG $G$ as input, whose vertices
have an associated property $tbl$ that contains a set of sub-strategies, and
returns a set of all possible valid strategies for $G$.
Line~\ref{ln:all-sub-strategies} of Alg.~\ref{alg:findoptstrategy} assigns all possible
sub-strategies to each vertex in $G$. It can be seen that just before
entering the loop at line~\ref{ln:loop-begin} in Alg.~\ref{alg:findoptstrategy},
we have $\optstrategy \in \Call{ValidStrategies}{G}$.

We will show that the invariant $(\exists\strategy \in
\Call{ValidStrategies}{G})[\Call{Cost}{G, \strategy} \le \optcost]$ is
maintained everywhere after line~\ref{ln:end-all-sub-strategies} in
Alg.~\ref{alg:findoptstrategy}.

\begin{theorem}\label{thm:optimality}
	Given an operation DAG $G=(V,E)$ and an optimal parallelization strategy
	$\optstrategy$ for $G$,  the invariant $(\exists\strategy \in
	\Call{ValidStrategies}{G})[\Call{Cost}{G, \strategy} \le \optcost]$ is
	maintained in any iteration of the loop $L$ in
	lines~\ref{ln:loop-begin}--\ref{ln:loop-end} of
	Alg.~\ref{alg:findoptstrategy}.

	\proof
	As a contradiction, consider that there exists an iteration $l$ of loop $L$
	where the invariant is violated for the first time. 
	Lines~\ref{ln:pick-opt} and \ref{ln:restrict-neigh} are the only places in
	loop $L$ where some of the valid sub-strategies are removed from $v.tbl$. We
	will consider both the cases below.

	Let $\phi_{l}$ be the set of valid strategies returned by
	$\Call{ValidStrategies}{G}$ at the beginning of an iteration $l$, and
	$\phi_{l+1}$ be the set of valid strategies returned at the end of iteration
	$l$.

	\paragraph{Case \rom{1}}
	Consider line~\ref{ln:pick-opt} of Alg.~\ref{alg:findoptstrategy}.
	Let $V' = V \setminus \set{\minv}$, and $E' = E \cap (V'\times V')$.
	Note that line~\ref{ln:pick-opt} only removes some of the configurations of
	the vertex $\minv$, i.e., ${\phi_l}_{|V'}$ does not change after execution of
	line~\ref{ln:pick-opt}. 

	Let $B$ denote the set of all $best$ sub-strategies picked in
	line~\ref{ln:pick-opt} in iteration $l$. For some $\strategy \in B$,
	let $B(\strategy_{|v.n})$ denote the configuration $c$ for $v$ s.t.
	$\set{(v,c)} \cup \strategy_{|v.n} = \strategy$.
	%$(\exists b \in B)[\strategy_{|v.n} \cup \set{(v,c)} = b]$. 
	It can be seen that $B(\strategy_{|v.n})$ is unique from the construction of
	$\mathcal{P}$ in line~\ref{ln:partition}. 
	
	We have,

	\begin{align}
		\optcost & = & \min_{\strategy \in \phi_l} \{\sum_{v \in V} \vertcost{v, \strategy(v)} +
			\sum_{(u,v)\in E} \edgecost{(u,v), \strategy(u), \strategy(v)}\}\nonumber\\
		& = & \min_{\strategy \in \phi_l}\{ \vertcost{\minv, \strategy(\minv)} +
			\sum_{(u, \minv) \in E} \edgecost{(u, \minv), \strategy(u),
			\strategy(\minv)}~+  \nonumber \\
			& & \sum_{(\minv, v) \in E} \edgecost{(\minv, v), \strategy(\minv),
			\strategy(v)} +
			\sum_{v\in V'} \vertcost{v, \strategy(v)} + \sum_{(u,v) \in E'}
			\edgecost{(u,v), \strategy(u), \strategy(v)} \} \nonumber\\
		& \ge & \min_{\strategy \in \phi_l} \{\vertcost{\minv,
		B(\strategy_{|\minv.n})} +
			\sum_{(u, \minv) \in E} \edgecost{(u, \minv), \strategy(u),
			B(\strategy_{|\minv.n})} ~+  \nonumber \\
			& & \sum_{(\minv, v) \in E} \edgecost{(\minv, v), B(\strategy_{|\minv.n}),
			\strategy(v)} +
			\sum_{v\in V'} \vertcost{v, \strategy(v)} +
			\sum_{(u,v) \in E'} \edgecost{(u,v), \strategy(u), \strategy(v)}
			\}\label{eq:best}
	\end{align}
	contradicting our assumption, as there exists a strategy $\strategy \in
	\phi_l$ and $\set{(\minv, B(\strategy_{|\minv.n})) \cup \strategy_{|V'}} \in
	\phi_{l+1}$ whose cost is equal to $\optcost$.

	Eq.~\ref{eq:best} above follows from the fact that
	\[
		best = \argmin_{\strategy_{|V''}} \sum_{v \in \set{\minv}\cup
		\minv.\neighbors} \vertcost{v, \strategy_{|V''}(v)} + \sum_{(u,v) \in
		E\setminus E'} \edgecost{(u,v), \strategy_{|V''}(u), \strategy_{|V''}(v)}
	\] 

	\paragraph{Case \rom{2}}
	Consider line~\ref{ln:restrict-neigh} in Alg.~\ref{alg:findoptstrategy}. As
	the computation in line~\ref{ln:restrict-neigh} removes a
	sub-strategy $S$ from $tbl$ only if there doesn't exist any valid strategy
	that comprises of $S$, no optimal strategy is eliminated in this step.

\qed
\end{theorem}


\end{document}
