\documentclass{article}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{algorithm,algpseudocode}
\usepackage[margin=1in]{geometry}

\algnewcommand{\LeftComment}[1]{\State \(\triangleright\) #1}
\algnewcommand{\LongComment}[2]{\Comment{\parbox[t]{#1}{#2}}}

\newcommand{\Inputs}[1]{\State \textbf{Input(s): }\parbox[t]{.8\textwidth}{#1}}
\newcommand{\Outputs}[1]{\State \textbf{Output(s): }\parbox[t]{.8\textwidth}{#1}}
\newcommand{\strategy}{\ensuremath{\mathcal{S}}}

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}
\newcommand{\set}[1]{\{#1\}}

\begin{document}

\begin{algorithm}
\caption{\label{alg:findoptstrategy}Algorithm to determine optimal parallelization
strategy for an operator DAG}

\begin{algorithmic}[1]
	\Procedure{FindOptStrategy}{$G=(V,E)$, $nprocs$}
	\Inputs{$G=(V,E):$ Operator DAG.\\
	$(\forall{v\in V})[v.dim]:$ Dimension of the iteration domain of the operation of
	$v$.\\
	$nprocs:$ Number of processors.}
	\Outputs{\strategy: Optimal parallelization starategy for $G$ }
	\Statex

	\ForAll{$v \in V$}
		\State $v.neighbors \leftarrow  \set{u ~|~ (u,v) \in E \lor (v,u) \in E}$
		\State $v.unprocessed\_neighbors \leftarrow v.neighbors$
		\State $v.processed \leftarrow \bot$
		\State $v.configs \leftarrow \set{(c_1, c_2,\dots,c_{v.dim}) ~|~
		(\forall{i\in[1,v.dim]})[c_i\in \mathbb{Z^+}]\land \prod_{i=1}^{v.dim} c_i \le
		nprocs}$
	\EndFor

	\Statex

	\LeftComment{Populate $v.tbl$ with all possible combinations of neighboring
	configurations. Each entry in $v.tbl$ is a sub-strategy for the nodes $\set{v}
	\cup v.neighbors$}
	\ForAll{$v \in V$}
		\State $v.tbl \leftarrow \prod_{u\in \set{v}\cup v.neighbors} \set{(u, cfg)
		~|~cfg \in u.configs}$
	\EndFor

	\Statex

	%\State $U \leftarrow \set{v \in V ~|~v.processed = \bot}$ 
	\State $U \leftarrow V$
	\Comment{Set of unprocessed vertices}
	\While{$U \not = \emptyset$}
		\LeftComment{Choose a vertex with least no. of unprocessed neighbors from
		$U$}
		%\ForAll{$v \in U$} 
		%	\State $v.unprocessed\_neighbors \leftarrow \set{u ~|~ u, v\in U \land u\in v.neighbors}$
		%\EndFor
		\State $v_{min} \leftarrow \argmin_{v\in U} |v.unprocessed\_neighbors|$
		\Statex

		\LeftComment{Partition $v_{min}.tbl$ such that in each set of the partition,
		all the neighbor configurations are the same. Refer
		Alg.~\ref{alg:is-compatible} for the function
		\Call{IsCompatible}{}}
		\State $\mathcal{P} \leftarrow \{S_1,S_2,\dots~|~$
		\parbox[t]{.75\textwidth}{
				$\cup_{S_i} = v_{min}.tbl \land i \not = j \implies S_i \cap S_j = \emptyset
				\land~\\(\forall s_x \in S_i)(\forall s_y \in S_i)[\Call{IsCompatible}{s_x, s_y, v_{min}.neighbors} = \top]
				\land~\\i \not = j \implies (\forall s_x \in S_i)(\forall s_y \in
				S_j)[\Call{IsCompatible}{s_x, s_y, v_{min}.neighbors} = \bot]
		\}$}
		\Statex
		\LeftComment{Iterate over each set $S \in \mathcal{P}$ and update
		$v_{min}.tbl$ so that it only contains the sub-strategy in $S$ that has the
		least cost.}
		\State $v_{min}.tbl \leftarrow \emptyset$
		\ForAll{$S \in \mathcal{P}$}
			\State \label{ln:opt-strategy} $best \leftarrow \argmin_{s\in S}
			\Call{Cost}{G, s}$
			\State $v_{min}.tbl \leftarrow v_{min}.tbl \cup \set{best}$
		\EndFor
		\Statex

		\ForAll{$v \in v_{min}.neighbors$}
			\LeftComment{Restrict the tables of the neighbors based on the best
			sub-strategies found for $v_{min}$ in Line~\ref{ln:opt-strategy}}
			\State $common = (v_{min}.neighbors \cap v.neighbors) \cup
			\set{v_{min}, v}$
			\State $v.tbl \leftarrow \set{entry_1\in v.tbl ~|~ (\exists
			entry_2 \in v_{min}.tbl)[\Call{IsCompatible}{entry_1, entry_2, common) =
			\top]}}$

			\Statex

			\State $v.unprocessed\_neighbors \leftarrow
			v.unprocessed\_neighbors\setminus \set{v_{min}}$
		\EndFor

		\Statex
		\State $v_{min}.processed \leftarrow \top$
		\State $U \leftarrow U\setminus \set{v_{min}}$
	\EndWhile
	\Statex

	%\LeftComment{Once all the vertices are processed, $v.tbl$ of all the vertices
	%should contain just a single entry.}
	\LeftComment{Collect all valid strategies for $G$ from $v.tbl$, and pick the
	one that minimizes the cost.}
	\State $\strategy' \leftarrow \Call{ValidStrategies}{G}$ \Comment{Refer
	Alg.~\ref{alg:valid-strategies}}
	\State $\strategy \leftarrow \argmin_{S\in \strategy'} \Call{Cost}{G, S}$
	%\ForAll{$v \in V$}
	%	\State $\strategy \leftarrow \strategy \cup sub\_strategy \in v.tbl$
	%\EndFor
	\State \Return{\strategy}

	\EndProcedure
\end{algorithmic}

\end{algorithm}

\begin{algorithm}
	\caption{\label{alg:is-compatible}Returns $\top$ if the two
	sub-strategies $S_1$ and $S_2$ have same configurations for the
	vertices in $V$.}

	\begin{algorithmic}[1]
		\Procedure{IsCompatible}{$S_1, S_2, V$}
			\State $N_1 \leftarrow \set{(n,c)\in S_1~|~n \in V}$
			\State $N_2 \leftarrow \set{(n,c)\in S_2~|~n \in V}$
			\Statex

			\If{$N_1 \not= N_2$}
				\State \Return{$\bot$}
			\EndIf
			\Statex
			\State \Return{$\top$}
		\EndProcedure
	\end{algorithmic}
\end{algorithm}


\begin{algorithm}
	\caption{\label{alg:valid-strategies} Returns a set of valid strategies}

	\begin{algorithmic}[1]
		\Procedure{ValidStrategies}{$G=(V,E)$}

		\State $\strategy \leftarrow \emptyset$
		\ForAll{$v \in V$}
			\If{$\strategy = \emptyset$}
				\State $\strategy \leftarrow v.tbl$
				\State \Call{Continue}{}
			\EndIf

			\Statex

			\State $\strategy' \leftarrow \emptyset$
			\ForAll{$S \in \strategy$}
				\ForAll{$T \in v.tbl$}
					\State $U_1 \leftarrow \set{u~|~(u,c)\in S}$
					\State $U_2 \leftarrow \set{u~|~(u,c)\in v.tbl}$
					\Statex
					\If{$\Call{IsCompatible}{S, T, U_1\cap U_2} = \top$}
						\State $\strategy' \leftarrow \strategy' \cup \set{S\cup T}$
					\EndIf
				\EndFor
			\EndFor
			\State $\strategy \leftarrow \strategy'$
		\EndFor

		\Statex
		\State\Return{$\strategy$}

		\EndProcedure

	\end{algorithmic}
\end{algorithm}


\end{document}
