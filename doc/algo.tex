\documentclass{article}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{algorithm,algpseudocode}
\usepackage[margin=1in]{geometry}

\algnewcommand{\LongComment}[2]{\Comment{\parbox[t]{#1}{#2}}}
\algnewcommand{\LeftComment}[1]{\State \(\triangleright\) #1}

\newcommand{\set}[1]{\{#1\}}
\newcommand{\seq}[1]{(#1)}

\DeclareMathOperator*{\argmin}{arg\,min}

\begin{document}

\section{Recurrence}
$$
min\_cost(v, SS_u) = \min_{cfg_v}~\{vert\_cost(v, cfg_v) + \sum_{n \in N_u(v)} edge\_cost(v,
n, cfg_v, SS_u(n)) + \sum_{n \in N_p(v)} min\_cost(n, SS_u\cup
\set{cfg_v})\} $$
where, $N_u(v)$ is the set of unprocessed neighbors of $v$, $N_p(v)$ is the set
of processed neighbors of $v$, $\sigma:V^*\rightarrow V^*$ is a function
that maps a set of processed vertices to their dependent unprocessed vertices,
and $SS_u$ is a map from $\sigma(N_p(v))$ to their configurations.


\section{Proof of optimality}
%for any strategy S1, min\_cost(v, S1) >= min\_cost(v, S).
%min\_cost(v, S1) >= min\_cost(u, S1) + vert\_cost(v, cfgv) + edge\_cost()


\section{Algorithm}

\begin{algorithm}
\caption{\label{alg:findoptstrategy}Algorithm to determine optimal parallelization
strategy for a computation DAG}

\begin{algorithmic}[1]
\Procedure{FindOptStrategy}{$G=(V,E)$, $nprocs$}
	%\Inputs{$G=(V,E):$ Computation DAG.\\

	\ForAll{$v \in V$}
		\State $v.processed \leftarrow \bot$
		\State $v.neigh \leftarrow \set{u\in V ~|~ (u, v) \in E \lor (v, u) \in E}$
		\State $v.depends \leftarrow v.neigh$
		\State \label{ln:all-configs} $v.tbl \leftarrow \set{\set{(v, (c_1,
		c_2,\dots,c_{v.dim}))} ~|~ \forall_{i \in [1,v.dim]} [c_i \in \mathbb{Z^+}] \land \prod_{i=1}^{v.dim} c_i \le
		nprocs}$ \\ \Comment{Set of all possible configurations}
	\EndFor
	\Statex

	\State $v \leftarrow \Call{GetNextVertex}{V, \bot}$
	\State $opt \leftarrow \emptyset$
	\While{$v \not= \bot$}
		\State $n_p \leftarrow \set{n \in v.neigh ~|~ n.processed = \top}$ \Comment{Processed neighbors of $v$}
		\State $n_u \leftarrow v.neigh \setminus n_p$ \Comment{Unprocessed neighbors of $v$}
		\Statex

		\LeftComment{Generate sub-strategies for $v$ and its surrounding nodes, by
		combining configs/sub-strategies of $v$ and its neighbors. Equivalent to
		\texttt{natural join} operation on the tables of $\set{v}\cup v.neigh$.}
		\State $tbl \leftarrow v.tbl$
		\ForAll{$n \in v.neigh$}
			\State $tbl \leftarrow \set{ss_i \cup ss_j~|~ss_i \in tbl \land ss_j
			\in n.tbl \land \Call{IsValid}{ss_i, ss_j}}$
		\EndFor
		\State $costs \leftarrow \Call{GetCosts}{v, n_u, n_p, tbl}$
		\Statex
		\State $v.costs \leftarrow \Call{GetMinCosts}{costs, n_u}$
		\State $v.tbl \leftarrow \set{cost(1) ~|~ cost \in v.costs}$
		\State $v.processed \leftarrow \top$
		\Statex

		\State $U \leftarrow \set{cfg(1) ~|~ cfg \in v.tbl}$ \Comment{$U$ is the
		vertex set in the sub-graph that was processed in this iteration}
		%\LeftComment{Update tables of $U$ to maintain consistency.}
		\ForAll{$u \in U$}
			\State $u.tbl \leftarrow v.tbl$
			\State $u.costs \leftarrow v.costs$
		\EndFor
		\State $opt \leftarrow v.tbl$
		\State $v \leftarrow \Call{GetNextVertex}{V, v}$
	\EndWhile
	\Statex

	\LeftComment{$v.tbl$ of the last vertex processed has exactly a single entry,
	that corresponds to the optimal strategy for $G$.}
	\State \Return{$opt$}

\EndProcedure
\end{algorithmic}
\end{algorithm}


\begin{algorithm}
\caption{\label{alg:isvalid}Returns $\top$ if combining two sub-strategies is
	valid. Two sub-strategies are considered to be invalid if there exists at
	least one vertex with different configurations in the two sub-strategies.}

\begin{algorithmic}[1]
\Procedure{IsValid}{$ss_1, ss_2$}

	\ForAll{$cfg_1 \in ss_1$}
		\ForAll{$cfg_2 \in ss_2$}
			\If{$cfg_1(1) = cfg_2(1) \land cfg_1(2) \not= cfg_2(2)$}
				\State \Return{$\bot$}
			\EndIf
		\EndFor
	\EndFor
	\Statex

	\State \Return{$\top$}

\EndProcedure
\end{algorithmic}
\end{algorithm}


\begin{algorithm}
	\caption{\label{alg:getcosts}Computes costs for different sub-strategies.}

\begin{algorithmic}[1]
	\Procedure{GetCosts}{$v, n_u, n_p, tbl$}
	\State $costs \leftarrow \emptyset$
	\ForAll{$ss \in tbl$}
		\State $cost \leftarrow 0$
		\State $ss_p \leftarrow \set{cfg \in ss ~|~ cfg(1) \in n_p}$
		\Comment{Processed neighbors' configs}
		\Statex
		\ForAll{$cfg \in ss$}
			\State $u \leftarrow cfg(1)$
			\If{$u = v$}
				\LeftComment{Add vertex cost for the current vertex $v$.}
				\State $cost \leftarrow cost + \Call{GetVertexCost}{v, cfg}$
			\ElsIf{$u \in n_u$}
				\LeftComment{Add edge costs for edges between $v$ and its unprocessed
				neighbor $u$.}
				\State $cost \leftarrow cost + \Call{GetEdgeCost}{v, u, cfg}$
			\ElsIf{$u \in n_p$}
				\LeftComment{Add the costs for sub-strategies of processed neighbor $u$
				from its \texttt{tbl}.}
				\State $cost_p \leftarrow \exists c_p [c_p \in u.costs \land
				\Call{IsValid}{c_p(1), ss_p}]$
				\State $cost \leftarrow cost + cost_p(2)$
			\EndIf
		\EndFor
		\Statex

		\State $costs \leftarrow costs \cup \set{(ss, cost)}$
	\EndFor

	\State \Return{$costs$}

	\EndProcedure
\end{algorithmic}
\end{algorithm}


\begin{algorithm}
	\caption{\label{alg:hassamess}Returns $\top$ if configs of $n_u$ are the same
	in all sub-strategies of $costs(1)$}

\begin{algorithmic}[1]
	\Procedure{HasSameSS}{$costs, n_u$}

	\ForAll{$cost_i \in costs$}
		\ForAll{$cost_j \in costs$}
			\State $ss_i \leftarrow \set{cfg \in cost_i(1) ~|~ cfg(1) \in n_u}$
			\State $ss_j \leftarrow \set{cfg \in cost_j(1) ~|~ cfg(1) \in n_u}$
			\If{\Call{IsValid}{$ss_i, ss_j$} = $\bot$}
				\State \Return{$\bot$}
			\EndIf
		\EndFor
	\EndFor
	\State \Return{$\top$}

	\EndProcedure
\end{algorithmic}
\end{algorithm}


\begin{algorithm}
	\caption{\label{alg:getmincosts}Minimizes $costs$ over processed neighbors.}

\begin{algorithmic}[1]
	\Procedure{GetMinCosts}{$costs, n_u$}

	\LeftComment{Partition $costs$ into mutually disjoint sets, such that
	all the elements of a set have the same sub-strategy for unprocessed vertices
	$n_u$.}
	\State $\mathcal{P} \leftarrow \set{C_1, C_2, \dots ~|~ i \not= j \implies
	C_i \cap C_j = \emptyset \land \cup_{i} C_i = costs \land
	\forall_i [\Call{HasSameSS}{C_i, n_u}]}$
	\Statex

	\LeftComment{Extract the strategy with minimum cost from each set of
	$\mathcal{P}$.}
	\State $min\_costs \leftarrow \emptyset$
	\ForAll{$P \in \mathcal{P}$}
		\State $min\_cost \leftarrow \argmin_{cost\in P} cost(2)$
		\State $min\_costs \leftarrow min\_costs \cup \set{min\_cost}$
	\EndFor
	\Statex

	\State \Return{$min\_costs$}

	\EndProcedure
\end{algorithmic}
\end{algorithm}


\begin{algorithm}
	\caption{\label{alg:getnextvertex}Returns the next vertex to be processed.}

\begin{algorithmic}[1]
	\Procedure{GetNextVertex}{$V, v_{prev}$}
	\If{$v_{prev}$}
		\ForAll{$v\in v_{prev}.depends$}
			\State $v.depends \leftarrow (v.depends \cup v_{prev}.depends) \setminus
			\set{v_{prev}, v}$
		\EndFor
	\EndIf
	\Statex

	\State $V_u \leftarrow \set{v\in V ~|~ v.processed = \bot}$
	\If{$V_u = \emptyset$}
		\State \Return{$\bot$}
	\EndIf
	\Statex 

	\State $v_{next} \leftarrow \argmin_{v\in V_u} |v.depends|$
	\State \Return{$v_{next}$}

	\EndProcedure
\end{algorithmic}
\end{algorithm}


\end{document}
